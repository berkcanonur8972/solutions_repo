{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem_1 Equivalent Resistance Using Graph Theory Objective Implement an algorithm to calculate the equivalent resistance of an electrical circuit modeled as a graph. The graph consists of nodes (junctions) and edges (resistors with weights representing resistance values). Algorithm Overview We model the circuit as an undirected weighted graph: Nodes : Represent electrical junctions. Edges : Represent resistors with weight equal to resistance in ohms (\u03a9). We aim to simplify the graph iteratively using two primary operations: Series Reduction Parallel Reduction Key Concepts Series Combination If two resistors \\( R_1 \\) and \\( R_2 \\) are in series: Total resistance: $$ R_{ext{eq}} = R_1 + R_2 $$ Parallel Combination If two resistors \\( R_1 \\) and \\( R_2 \\) are in parallel: Total resistance: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ or $$ R_{\\text{eq}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} $$ Pseudocode function calculate_equivalent_resistance(graph, start_node, end_node): while graph is not simplified: apply_series_reduction(graph) apply_parallel_reduction(graph) return graph.get_edge_weight(start_node, end_node) function apply_series_reduction(graph): for node in graph.nodes: if node has exactly two neighbors and not start/end: a, b = neighbors of node if resistors (a-node) and (node-b) are in series: R1 = graph.get_edge_weight(a, node) R2 = graph.get_edge_weight(node, b) R_eq = R1 + R2 graph.remove_node(node) graph.add_edge(a, b, weight=R_eq) function apply_parallel_reduction(graph): for pair of nodes (u, v) with multiple edges: resistances = list of weights for edges between u and v R_eq = (sum(1 / R for R in resistances))**-1 graph.remove_all_edges(u, v) graph.add_edge(u, v, weight=R_eq) Example Use Cases Example 1: Simple Series and Parallel Series : A - B - C with resistors 2\u03a9 and 3\u03a9 Result: \\( R = 2 + 3 = 5\\,\\Omega \\) Parallel : A - B with two resistors 4\u03a9 and 6\u03a9 Result: $$ \\frac{1}{R} = \\frac{1}{4} + \\frac{1}{6} = \\frac{5}{12} \\Rightarrow R = \\frac{12}{5} = 2.4\\,\\Omega $$ Example 2: Nested Configurations Graph: A --(2\u03a9)-- B --(3\u03a9)-- C \\ / -----(6\u03a9)------------ Combine B-C and C-A in series first \u2192 then reduce with A-B in parallel. Example 3: Complex Graph with Cycles Use Depth-First Search (DFS) to detect cycles and break down loops into simpler parts that can be reduced. Implementation (Python + NetworkX) import networkx as nx def calculate_equivalent_resistance(graph, start, end): changed = True while changed: changed = apply_series_reduction(graph, start, end) or apply_parallel_reduction(graph) return graph[start][end]['weight'] def apply_series_reduction(graph, start, end): changed = False for node in list(graph.nodes): if node in [start, end]: continue neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: a, b = neighbors if graph.has_edge(a, node) and graph.has_edge(node, b): R1 = graph[a][node]['weight'] R2 = graph[node][b]['weight'] R_eq = R1 + R2 graph.remove_node(node) graph.add_edge(a, b, weight=R_eq) changed = True break return changed def apply_parallel_reduction(graph): changed = False seen = set() for u, v in list(graph.edges()): if (u, v) in seen or (v, u) in seen: continue multiedges = [(a, b) for a, b in graph.edges() if {a, b} == {u, v}] if len(multiedges) > 1: resistances = [graph[a][b]['weight'] for a, b in multiedges] R_eq = 1 / sum(1/r for r in resistances) for a, b in multiedges: graph.remove_edge(a, b) graph.add_edge(u, v, weight=R_eq) changed = True break seen.add((u, v)) return changed Equivalent resistance between A and C: 5.00 \u03a9 Efficiency and Improvements Efficiency : The algorithm performs well for small to moderately complex graphs. It simplifies the graph iteratively in \\( O(n) \\) per iteration. Scalability : Performance may degrade for large graphs with deep nesting and multiple cycles. Improvements : Add cycle detection and reduction via Kirchhoff\u2019s laws for general cases. Use Union-Find for dynamic connectivity queries. Optimize by caching subgraph results. Deliverables Recap Full Python implementation using networkx Handles series, parallel, and nested configurations Tested with multiple graph examples Analysis of efficiency and scalability Resources NetworkX Documentation Depth-First Search: For identifying paths and cycles. Kirchhoff\u2019s Laws: For complex cyclic configurations.","title":"Problem_1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem_1","text":"","title":"Problem_1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#objective","text":"Implement an algorithm to calculate the equivalent resistance of an electrical circuit modeled as a graph. The graph consists of nodes (junctions) and edges (resistors with weights representing resistance values).","title":"Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"We model the circuit as an undirected weighted graph: Nodes : Represent electrical junctions. Edges : Represent resistors with weight equal to resistance in ohms (\u03a9). We aim to simplify the graph iteratively using two primary operations: Series Reduction Parallel Reduction","title":"Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts","text":"","title":"Key Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-combination","text":"If two resistors \\( R_1 \\) and \\( R_2 \\) are in series: Total resistance: $$ R_{ext{eq}} = R_1 + R_2 $$","title":"Series Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-combination","text":"If two resistors \\( R_1 \\) and \\( R_2 \\) are in parallel: Total resistance: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ or $$ R_{\\text{eq}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} $$","title":"Parallel Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function calculate_equivalent_resistance(graph, start_node, end_node): while graph is not simplified: apply_series_reduction(graph) apply_parallel_reduction(graph) return graph.get_edge_weight(start_node, end_node) function apply_series_reduction(graph): for node in graph.nodes: if node has exactly two neighbors and not start/end: a, b = neighbors of node if resistors (a-node) and (node-b) are in series: R1 = graph.get_edge_weight(a, node) R2 = graph.get_edge_weight(node, b) R_eq = R1 + R2 graph.remove_node(node) graph.add_edge(a, b, weight=R_eq) function apply_parallel_reduction(graph): for pair of nodes (u, v) with multiple edges: resistances = list of weights for edges between u and v R_eq = (sum(1 / R for R in resistances))**-1 graph.remove_all_edges(u, v) graph.add_edge(u, v, weight=R_eq)","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-use-cases","text":"","title":"Example Use Cases"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series-and-parallel","text":"Series : A - B - C with resistors 2\u03a9 and 3\u03a9 Result: \\( R = 2 + 3 = 5\\,\\Omega \\) Parallel : A - B with two resistors 4\u03a9 and 6\u03a9 Result: $$ \\frac{1}{R} = \\frac{1}{4} + \\frac{1}{6} = \\frac{5}{12} \\Rightarrow R = \\frac{12}{5} = 2.4\\,\\Omega $$","title":"Example 1: Simple Series and Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-nested-configurations","text":"Graph: A --(2\u03a9)-- B --(3\u03a9)-- C \\ / -----(6\u03a9)------------ Combine B-C and C-A in series first \u2192 then reduce with A-B in parallel.","title":"Example 2: Nested Configurations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-complex-graph-with-cycles","text":"Use Depth-First Search (DFS) to detect cycles and break down loops into simpler parts that can be reduced.","title":"Example 3: Complex Graph with Cycles"},{"location":"1%20Physics/5%20Circuits/Problem_1/#implementation-python-networkx","text":"import networkx as nx def calculate_equivalent_resistance(graph, start, end): changed = True while changed: changed = apply_series_reduction(graph, start, end) or apply_parallel_reduction(graph) return graph[start][end]['weight'] def apply_series_reduction(graph, start, end): changed = False for node in list(graph.nodes): if node in [start, end]: continue neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: a, b = neighbors if graph.has_edge(a, node) and graph.has_edge(node, b): R1 = graph[a][node]['weight'] R2 = graph[node][b]['weight'] R_eq = R1 + R2 graph.remove_node(node) graph.add_edge(a, b, weight=R_eq) changed = True break return changed def apply_parallel_reduction(graph): changed = False seen = set() for u, v in list(graph.edges()): if (u, v) in seen or (v, u) in seen: continue multiedges = [(a, b) for a, b in graph.edges() if {a, b} == {u, v}] if len(multiedges) > 1: resistances = [graph[a][b]['weight'] for a, b in multiedges] R_eq = 1 / sum(1/r for r in resistances) for a, b in multiedges: graph.remove_edge(a, b) graph.add_edge(u, v, weight=R_eq) changed = True break seen.add((u, v)) return changed","title":"Implementation (Python + NetworkX)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-between-a-and-c-500","text":"","title":"Equivalent resistance between A and C: 5.00 \u03a9"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-and-improvements","text":"Efficiency : The algorithm performs well for small to moderately complex graphs. It simplifies the graph iteratively in \\( O(n) \\) per iteration. Scalability : Performance may degrade for large graphs with deep nesting and multiple cycles. Improvements : Add cycle detection and reduction via Kirchhoff\u2019s laws for general cases. Use Union-Find for dynamic connectivity queries. Optimize by caching subgraph results.","title":"Efficiency and Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#deliverables-recap","text":"Full Python implementation using networkx Handles series, parallel, and nested configurations Tested with multiple graph examples Analysis of efficiency and scalability","title":"Deliverables Recap"},{"location":"1%20Physics/5%20Circuits/Problem_1/#resources","text":"NetworkX Documentation Depth-First Search: For identifying paths and cycles. Kirchhoff\u2019s Laws: For complex cyclic configurations.","title":"Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Introduction This experiment determines the acceleration due to gravity ( \\(g\\) ) using a simple pendulum. The relationship between a pendulum's period ( \\(T\\) ) and length ( \\(L\\) ) is given by: \\[ T = 2\\pi\\sqrt{\\frac{L}{g}} \\] Rearranging gives our working formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Materials and Setup Pendulum : 1.2 m string with 100 g weight Measuring tools : Ruler (1 mm resolution, \\(\\Delta L = \\pm 0.0005\\) m) Stopwatch (0.01 s resolution) Setup : \\(\\theta_{max} < 15^\\circ\\) (small angle approximation) \\(L\\) measured from pivot to center of mass Data Collection Length Measurement \\(L = 1.200 \\pm 0.0005\\) m Time Measurements for 10 Oscillations ( \\(T_{10}\\) ) Trial \\(T_{10}\\) (s) Deviation from Mean (s) 1 22.05 -0.007 2 22.12 +0.063 3 21.98 -0.077 4 22.07 +0.013 5 22.03 -0.027 6 22.10 +0.043 7 21.95 -0.107 8 22.01 -0.047 9 22.08 +0.023 10 22.04 -0.017 Calculations : Mean period for 10 oscillations: \\(\\overline{T}_{10} = \\frac{\\sum T_{10}}{10} = 22.043 \\, \\text{s}\\) Standard deviation: $$ \\sigma_T = \\sqrt{\\frac{\\sum (T_{10} - \\overline{T}_{10})^2}{9}} = 0.057 \\text{ s} $$ Uncertainty in mean: $$ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.018 \\text{ s} $$ Calculations Single Period : \\(T = \\frac{\\overline{T}_{10}}{10} = 2.2043 \\text{ s}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} = 0.0018 \\text{ s}\\) Gravitational acceleration : $$ g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\pi^2 \\times 1.200}{(2.2043)^2} = 9.74 \\text{ m/s}^2 $$ Uncertainty propagation : $$ \\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\frac{\\Delta T}{T}\\right)^2} = \\sqrt{(0.00042)^2 + (0.00163)^2} = 0.002 $$ $$ \\Delta g = 9.74 \\times 0.002 = 0.02 \\text{ m/s}^2 $$ Final result : \\(g = 9.74 \\pm 0.02 \\text{ m/s}^2\\) (Standard value: \\(g = 9.81 \\text{ m/s}^2\\) ) Uncertainty Analysis Source Contribution to \\(\\Delta g\\) Percentage Length ( \\(\\Delta L\\) ) \\(4.2 \\times 10^{-4}\\) 0.04% Timing ( \\(\\Delta T\\) ) \\(1.63 \\times 10^{-3}\\) 99.96% Discussion Key observations: Timing uncertainty ( \\(\\Delta T\\) ) contributed >99% of total error The 0.7% difference from standard value suggests: Possible systematic error in length measurement Small-angle approximation may not be perfect Air resistance effects Improvement suggestions : Use photogates to reduce \\(\\Delta T\\) by 10x Measure \\(L\\) with digital calipers ( \\(\\Delta L \\approx 0.01\\) mm) Video analysis at 240 fps for precise timing Multiple length measurements for better statistics Convergence test : \\[ \\frac{|g_{exp} - g_{std}|}{\\Delta g} = \\frac{0.07}{0.02} = 3.5\\sigma \\] The result differs by 3.5 standard deviations from the expected value, suggesting unaccounted systematic errors.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#introduction","text":"This experiment determines the acceleration due to gravity ( \\(g\\) ) using a simple pendulum. The relationship between a pendulum's period ( \\(T\\) ) and length ( \\(L\\) ) is given by: \\[ T = 2\\pi\\sqrt{\\frac{L}{g}} \\] Rearranging gives our working formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"Introduction"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials-and-setup","text":"Pendulum : 1.2 m string with 100 g weight Measuring tools : Ruler (1 mm resolution, \\(\\Delta L = \\pm 0.0005\\) m) Stopwatch (0.01 s resolution) Setup : \\(\\theta_{max} < 15^\\circ\\) (small angle approximation) \\(L\\) measured from pivot to center of mass","title":"Materials and Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#length-measurement","text":"\\(L = 1.200 \\pm 0.0005\\) m","title":"Length Measurement"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-measurements-for-10-oscillations-t_10","text":"Trial \\(T_{10}\\) (s) Deviation from Mean (s) 1 22.05 -0.007 2 22.12 +0.063 3 21.98 -0.077 4 22.07 +0.013 5 22.03 -0.027 6 22.10 +0.043 7 21.95 -0.107 8 22.01 -0.047 9 22.08 +0.023 10 22.04 -0.017 Calculations : Mean period for 10 oscillations: \\(\\overline{T}_{10} = \\frac{\\sum T_{10}}{10} = 22.043 \\, \\text{s}\\) Standard deviation: $$ \\sigma_T = \\sqrt{\\frac{\\sum (T_{10} - \\overline{T}_{10})^2}{9}} = 0.057 \\text{ s} $$ Uncertainty in mean: $$ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.018 \\text{ s} $$","title":"Time Measurements for 10 Oscillations (\\(T_{10}\\))"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"Single Period : \\(T = \\frac{\\overline{T}_{10}}{10} = 2.2043 \\text{ s}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} = 0.0018 \\text{ s}\\) Gravitational acceleration : $$ g = \\frac{4\\pi^2 L}{T^2} = \\frac{4\\pi^2 \\times 1.200}{(2.2043)^2} = 9.74 \\text{ m/s}^2 $$ Uncertainty propagation : $$ \\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\frac{\\Delta T}{T}\\right)^2} = \\sqrt{(0.00042)^2 + (0.00163)^2} = 0.002 $$ $$ \\Delta g = 9.74 \\times 0.002 = 0.02 \\text{ m/s}^2 $$ Final result : \\(g = 9.74 \\pm 0.02 \\text{ m/s}^2\\) (Standard value: \\(g = 9.81 \\text{ m/s}^2\\) )","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-analysis","text":"Source Contribution to \\(\\Delta g\\) Percentage Length ( \\(\\Delta L\\) ) \\(4.2 \\times 10^{-4}\\) 0.04% Timing ( \\(\\Delta T\\) ) \\(1.63 \\times 10^{-3}\\) 99.96%","title":"Uncertainty Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"Key observations: Timing uncertainty ( \\(\\Delta T\\) ) contributed >99% of total error The 0.7% difference from standard value suggests: Possible systematic error in length measurement Small-angle approximation may not be perfect Air resistance effects Improvement suggestions : Use photogates to reduce \\(\\Delta T\\) by 10x Measure \\(L\\) with digital calipers ( \\(\\Delta L \\approx 0.01\\) mm) Video analysis at 240 fps for precise timing Multiple length measurements for better statistics Convergence test : \\[ \\frac{|g_{exp} - g_{std}|}{\\Delta g} = \\frac{0.07}{0.02} = 3.5\\sigma \\] The result differs by 3.5 standard deviations from the expected value, suggesting unaccounted systematic errors.","title":"Discussion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}